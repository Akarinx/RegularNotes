/**
 * 所谓不动笔墨不读书系列
 * 其实STL库很必要了解
 * awk，需要了解一下
 * 检测进程 ps -ef|grep process
 * grep是一个过滤器，等会需要好好了解一下
 * shell是一个好东西，直接操作bash，写了sh就能直接运行
 * 
 * 所谓不懂笔墨不读书
 * 接下来就耀好好读读书
 * 
 * 解析共享库工作机理，灵活组织大型项目
 * 
 * 共享库
 * 共享库产生的渊源
 * 静态库 在共享库出现之前，公用功能以静态库的形式存在，通用功能模块的多个目标文件打包在一起
 * 用到它的程序只需要在链接时指定这个库文件，连接器就会从这个库中抽取出用到的功能代码拷贝到目标程序中
 * 而不需要每次都对这些通用功能代码重新编译
 * 
 * 静态库逐渐暴露了问题
 * 一是磁盘和内存空间占用大。需要占用物理内存
 * 二是库的版本升级非常麻烦。每个引用到它的程序都需要与新版本的库重新链接
 * 
 * 共享库解决静态库问题
 * 只在目标文件中记录一条引用信息，标记引用到的库函数，直到程序运行时才由动态连接器去定位功能代码的位置
 * 每个共享库在物理内存中只有一份副本，多个应用会在各自的虚拟地址空间内映射这同一份可执行文件，因此可以节省客观的内存空间
 * 
 * 共享库工作的关键在于运行时的动态加载和链接，因此也叫做动态链接库
 * 同一个库在不同进程中的映射地址是不同的，为了解决多个库加载地址可能冲突的问题
 * 
 * 动态库技术需要解决两个问题
 * 1. 库代码需要能在任意内存地址运行
 * 2. 映射之后库之间互相引用的代码能定位到正确的地址
 * 
 * 静态共享库 模块装载地址的问题。 操作系统统一管理各种模块的加载地址
 * 
 * 位置独立的代码 支持任意地址加载运行
 * GCC生成位置独立的代码，需要使用-fPIC选项。需要以特定的方式生成获取变量和函数地址的代码
 * 
 * ***/
#include <stdio.h>
static int static_val;
extern int extern_val;
int global_val;

extern void external();

static void internal() {
    static_val = 0x11223344;
}

void sharefunc(int caller) {
    internal(); // 模块内部函数调用
    extern_val = 0x55667788; // 模块内部数据访问
    global_val = 0x99AABBCC; // 模块间的数据访问
    external(); // 模块间的函数调用
}

/**
 * 编译成动态链接库
 * gcc -fPIC -shared -o libshared.so shared.c
 * 
 * 反汇编 objdump
 * 
 * objdump -SD libshared.so > libshared.dump
 * 
 * 模块内部的函数调用
 * 
 * 根据生成的汇编码 e8 da ff ff ff 在intel编程手册可见，e8是香港队地址跳转的call指令的操作码，功能是调用下一条指令地址
 * 算起偏移指定的偏移量的函数
 * 寻址方式天生就是与加载地址无关，所以不需要对动态库做特殊处理
 * ***/

