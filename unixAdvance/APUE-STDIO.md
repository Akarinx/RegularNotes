## 标准IO库
不仅仅是UNIX，很多其他操作系统都实现了标准IO库，所以这个库可以说是可移植性比较强的！深刻理解标准io库比较关键。<br>
### 流和FILE对象
unix，一切皆文件。在系统I/O中，所有的I/O函数都是围绕着文件描述符的。当打开一个文件时，即返回一个文件描述符。然后后续该文件描述符就用于后续的I/O操作。<br>
================华丽丽的分割线=================<br>
标准IO库，围绕着流进行（stream），当使用标准I/O库打开或创建一个文件时，我们已 **使一个流与一个文件相关联**。<br>
标准io文件流可以用于单字节或多字节（“宽”）字符集。流的定向决定了所读、写的字符是单字节还是多字节的。
**当一个流最初被创建时，没有定向**
* 未定向的流使用一个多字节io函数`（<wchar.h>)`，则将该流设置为宽定向
* 若使用一个单子节io函数，则将该流的定向设为字节定向<br>
两个函数，改变定向
```c
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp,int mode);
// above可以用于设置流的定向。宽定向 返回正，字节定向，返回负，未定向返回0.
// mode 为负 将流指定为字节定向 正 宽定向 0 不设置 返回标识该流定向的值
int freopen();
```
### 标准输入、标准输出和标准错误
STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO<br>
这三个流可以自动地被进程使用。<br>
预定义文件指针 stdin,stdout和stderr加以引用
<br>
### 缓冲
标准io库提供缓冲的目的是尽可能减少使用read和write调用的次数。<br>
它也对每个io流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。
#### 全缓冲
填满了io缓冲区后才进行io操作。对于驻留在磁盘上的文件通常是由标准io库实施全缓冲的。在一个流上执行第一次io操作时，相关标准io函数常调用malloc获得需使用的缓冲区（原来malloc用来获取需使用的缓冲区）<br>
flush冲一冲，说明标准io缓冲区的些操作。可调用一个fflush，冲一冲一个流。冲一冲，就是冲一冲，将数据冲到磁盘上。
#### 行缓冲
遇到换行符，标准ℹ️😯执行io操作。允许我们一次输出一个字符，但是只有写了一行之后才输出。终端常用行缓冲。<br>
**限制** 1. 收集每一行的缓冲区的长度是固定的，填满缓冲区，即使没有一个换行符，也会操作，冲一冲。<br>
2. 任何时候只要通过标准io库要求 A->一个不带缓冲的流 B->一个行缓冲的流（需要从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流。<br>
一个不带缓冲的流中输入，需要从内核获得数据。换句话说，不带缓冲输入？就要从内核获得数据。
#### 不带缓冲
标准io库不对字符进行缓冲存储。例如write()函数<br>
标准错误流是不带缓冲的stderr。<br>
不交互：全缓冲。<br>
标准错误：不能全缓冲（不带缓冲或行缓冲）常不带缓冲<br>
指向终端，行缓冲，否则全缓冲<br>
不喜欢默认？下面函数帮助你。<br>
```c
void setbuf(FILE *restrict fp,char *restrict buf);
int setbuf(FILE *restrict fp,char *restrict buf,int mode,size_t size);
```
这些函数一定要在流已被打开后调用。这里的每一个函数都要求有一个有效文件指针。有效文件指针！！！mode参数_IOFBF、_IOLBF、_IONBF<br>
```c
fflush(FILE *fp);//  此函数使该流所有未写的数据都传送至内核。NULL就表示所有输出流都被冲洗 成功返回0 出错 EOF
```
### 打开流