## 进程关系 & 守护进程
每个进程都有一个父进程，当子进程结束时，会通知父进程，父进程取得子进程的退出状态，然后让子进程等待收尸。<br>
那么进程除了有父子关系外，还有哪些关系呢？先来看看一个笨设备<br>
### 终端(我只会接收命令并返回结果)
一台计算机可以有多个终端，多个终端，可以让多个人使用同一台电脑。那么Linux是如何让多个用户登陆呢？<br>
![Linux用户登录过程](./img/linuxlogin.png)<br>
内核自举时创建1号init进程，init对每一个终端执行fork+exec+getty命令。getty命令的作用就是要求用户输入用户名。<br>
登陆过程:<br>
等待用户输入完成用户名后，getty会exec+login<br>
login->getpwnam()(得到用户的口令文件登录项)->getpass()(以屏蔽回显的形式获得用户的密码)->crypt()(将加密的用户口令与阴影口令文件用户登录项中的pw_passwd比较)->失败？重新init:启动shell并用chown()更改当前登陆终端的所有权。<br>
登陆之前的步骤都是root身份，所以真正用户权限被降下来就是在登陆之后发生。<br>
### 会话(相当于进程组的容器，承载一个或多个进程组)
一次成功的终端登陆就是一个会话，现在一次shell的成功登录，相当于那时候终端的成功登录。会话相当于进程组的容器，他能承载一个或多个进程组。
![会话中进程组的安排](./img/process_session.png)<br>
进程调用setsid函数建立一个新会话<br>
```c
#include <unistd.h>
pid_t setsid(void);
// 成功但会进程组ID，出错返回-1
pid_t getsid(pid_t pid);
// 成功返回会话首进程的进程组ID，出错返回-1
```
如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。<br>
* 该进程变成新会话的会话首进程(session leader，会话首进程是创建该会话的进程)。此时，该进程是新会话的唯一进程。
* 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID
* 该进程美誉控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断。<br>
如果是，返回出错，一般都是先用父进程fork，然后等父进程死亡，子进程继续，这样子进程就不是一个进程组组长。子进程继续调用setsid，将自己成为守护进程。(这就是为什么，PID,PGID,SID是相同的)
### 进程组(承载进程)
一个进程组中有一个或多个进程，它是一个或多个进程的集合(也可以看作是容器)。一个进程不但拥有唯一的PID，同时也属于一个进程组。<br>
进程组是在统一作业中结合起来的。同一个进程组中的个进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID(一个正整数)，并存放在pid_t数据类型中。
```c
#include <unistd.h>
pid_t getpgrp(void)；
// 调用进程的进程组ID
```
实例
```c
#include "../include/apue.h"
#include <unistd.h>

int main(){
    pid_t pid;
    pid = getpgrp();
    printf("gid = %d\n",pid);
    return 0;
}
```
每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID<br>
进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间成为进程组的生命期。 **某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。**<br>
进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组<br>
```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
// 成功，返回0，出错，返回-1
```
setpgid函数将pid进程的额进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外， **如果pgid是0，则由pid指定的进程ID用作进程组ID。**<br>
一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后，他就不能再更改该子进程的进程组ID。<br>
大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID。因这样也 **保证了执行的先后顺序问题，这样保证了不会发生竞争条件**<br>
waitpid函数可被用来等待一个进程或者指定进程组中的一个进程终止。<br>
进程组分为前台进程和后台进程，一个会话只能有一个前台进程组，也可以没有。<br>
终端不能与后台进程通信。后台进程+`&`。<br>
#### 会话用来承载进程组，进程组用来承载进程，进程用来承载线程
