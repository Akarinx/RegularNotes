首先来看看着23个模式
# 创建类型模式 单例、原型、工厂方法、抽象工厂、建造模式
## 单例模式（我就是我，不一样的烟火）
cpp effective 55 说过，如果你不想让别人可以构造你，你就把你的构造函数声明为private吧。<br>
```cpp
class Brother{
    private:
        Brother(){
            cout << "only me is you brother" << endl;
        };
};
```
确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br>
优点：<br>
* 只有一个实例，一个对象需要频繁地创建，销毁，而且创建或销毁时性能无法优化，就需要一个实例，删除，销毁，也只有一个实例。
* 单例模式只生成一个实例，所以较少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置，产生其他依赖对象，就可以在应用启动的时候，直接产生一个单例对象。然后永久驻留内存。<br>
* 避免资源多重占用，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。
* 单例模式可以在系统设置全局的访问点，优化和共享资源访问。<br>
缺点：<br>
* 没有接口
* 测试不利
* 与单一职责原则有冲突
所以要结合场景需求，一般与原则不符，就需要多多考虑。<br>
**场景：**<br>
要求一个类有且仅有一个对象。
而且在高并发的状态，需要判断这个单例是否存在！<br>
多个实例会很麻烦！<br>
**扩展一下:**<br>
设定上限产生对象。
```cpp
class Brother{
    private:
        Brother(){
            cout << "only me is you brother" << endl;
        };
        list<Brother> listBrother;
        for(){
            listBrother.add()...
        }
};
```
所以上面又叫做有上限的多例模式。<br>
## 原型模式 clone
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建❤️新对象。<br>
其实就是拷贝一个对象，不用新创建它，直接拷贝它，然后你后面的资源就没了<br>
参见cpp的右值引用
