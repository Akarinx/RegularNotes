#### C++中的构造函数和析构函数可以抛出异常吗？
其实不建议在构造函数抛出异常，一旦抛出异常，所有的程序都将停止执行，析构函数也不会执行，需要手动去释放内存。<br>
析构函数不应该抛出异常，析构函数抛出异常，程序自动立刻杀死进程。析构函数处理异常应该将异常封装在析构函数内部，而不是抛出。如果抛出，就会继续递归自己的析构函数，无限递归。<br>

#### memmove() 可以在源地址和目的地址的位置任意的情况下，在源地址和目的地址的空间大小任意的情况下实现二进制代码块的复制
memcpy与memmove的目的都是将N个自己的源内存地址的内容拷贝到目标内存地址中。但当源内存和目标内存存在重叠时，memcpy会出错，而memmove能正确地实施拷贝，但也增加了一点点开销。

#### 如果要实现一个多线程(非mfc)程序，选择多线程CRT，创建线程的时候应该用CreateThread还是_beginthreadex()?
_beginthreadex()比较于CreateThread()有更高的线程安全性，不会造成多个线程共用同一个全局变量的情况。每个线程都将拥有自己专用的一块内存区域来供白准C运行库中所有需要的函数使用。

#### 函数模板的实例化是由编译程序在处理函数调用时自动完成的
类模版的实例化必须由程序员在程序中显式地指定
