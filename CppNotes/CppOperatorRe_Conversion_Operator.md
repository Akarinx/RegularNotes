这章节是第十四章。这章介绍运算符重载，这种机制允许内置运算符作用于类类型的运算对象。这样我们创建的类型直观上就可以像内置类型一样使用，运算符重载是C++借以实现这一目的的方法之一。<br>
类可以重载的运算符中有一种特殊运算符---函数调用运算符。对于重载了这种运算符的类，我们可以“调用”其对象，就好像它们是函数一样。新标准库中提供了一些设施，使得不同类型的可调用对象可以以一种一致的方式来使用，我们也将介绍这部分内容。<br>
最后将介绍另一种特殊类型的类成员函数---转换运算符。这些运算符定义了类类型对象的隐式转换机制。编译器应用这种转换机制的场合与原因都与内置类型转换是一样的。<br>
那么，在第四章中我们看到C++语言定义了大量的运算符以及内置类型的自动转换规则。这些特性使得程序员能编写出形式丰富、含有多种混合类型的表达式。<br>
当运算符被用于类类型的对象时，C++语言允许我们为其制定新的含义；同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象<br>
@ 当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。<br>
## 基本概念
**重载的运算符时具有特殊名字的函数**：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。<br>
**重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符又一个参数，二元运算符有两个。**<br>
@ 对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。<br>
@ 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。<br>
📒 当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。<br>
**约定：对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数:**<br>
```cpp
// ❌ 不能为int重定义内置的运算符
int operator+(int,int);
```
这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。<br>
**我们可以重载大多数（但不是全部）运算符。**<br>
我们只能重载已有的运算符，而无权发明新的运算符号。<br>
有四个符号（+，-，*，&）即是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符。<br>
@ 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。<br>
可以重载的运算符太多，这里列举不能重载的运算符<br>
```cpp
::    .*    .    ?:
```
#### 直接调用一个重载的运算符函数
通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参：
```cpp
// 一个非成员运算符函数的等价调用
data1+data2;
// 基于“调用”的表达式
operator+(data2,data2);
// 对成员运算符函数的等价调用
```
两次调用都是等价的，它们都调用了非成员函数operator+。传入的data1是第一个实参，传入data2作为第二个实参<br>
显式地调用成员运算符函数。
```cpp
// 基于“调用”的表达式
data1 += data2;
data1.operator+=(data2);
// 对成员运算符函数的等价调用 将this绑定到data1的地址、将data2作为实参传入了函数。
```
#### 某些运算符不应该被重载
@ 使用重载的运算符本质上是一次函数调用，所以关于运算对象求值顺序的规则无法应用到重载的运算符上。<br>
特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序无法保留下来.除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。<br>
我们一般不重载逗号运算符和取地址运算符。<br>
✨ 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符<br>

#### 使用内置类型一直的含义
当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：<br>
@ 如果类执行IO操作，则定义移位运算符使其与内置类型的IO操作保持一致。<br>
@ 如果类的某个操作是检查相等性，则定义operator==；如果类有了operator==，意味着它通常也应该有operator!=。<br>
@ 如果类包含一个内在的单序比较操作，则定义operator<；如果类有了operator<,则它也应该 含有其他关系操作。<br>
@ 重载运算符的返回类型通常情况下应该与其内置类型版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。<br>
💡 **尽量明智滴使用运算符重载。**<br>
每个运算符在用于内置类型时都有比较明确的含义。以二元+运算符为例，它明显执行的是加法操作。因此，把二元+运算符映射到类类型的一个类似操作上可以极大地简化记忆。<br>
#### 赋值和复合赋值运算符
赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。**重载的赋值运算应该继承而非违背其内置版本的含义**<br>
#### 选择作为成员或者非成员
当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。<br>
将运算符定义为成员函数还是普通的非成员函数的准则以及抉择:<br>
@ 赋值（=），下标（[]),调用(（）)和成员访问箭头（->）运算符必须是成员。<br>
@ 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。<br>
@ 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、和解引用运算符，通常应该是成员<br>
@ 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。<br>
程序员希望能在含有混合类型的表达式中使用对称性运算符。🌰 我们能求一个int 和 double的和，因为它们中的任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。**如果我们想提供含有类对象的混合类型表达式，则运算符必须定义非成员函数。**<br>
当我们把运算符定义成成员函数时，它的左侧运算对象必须时运算符所属类的一个对象。<br>
🌰 ：
```cpp
string s = "world";
string t = s+')'; // 可以把一个const char*加到一个string对象中 s.operator+(')')
string u = "hi"+s; // 如果+是string的成员，则产生错误。
```
因为string将+定义成了普通的非成员函数，所以"hi"+s等价于operator+("hi",s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少又一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string.<br>
❓ 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？<br>
我们可以直接调用重载运算符函数。重置运算符与内置运算符有一样的优先级与结合性。<br>
```cpp
#include <string>
#include <iostream>
class Sales_data{
    friend std::istream& operator>>(istream&, Sales_data&); // input
    friend std::ostream& operator<<(ostream&, const Sales_data&); //output
    friend Sales_data operator+(const Sales&, const Sales_Data&);
    ...
    Sales_data& operator+=(const Sales_data&);
}
```
### 输入和输出运算符
IO标准库分别使用>>和<<执行输入和输出操作。对于两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作<br>
#### 重载输出运算符<<
通常情况下，输出运算符的**第一个形参是一个非常量ostream对象的引用**。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。<br>
**第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。**第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为（通常情况下）打印对象不会改变对象的内容。<br>
为了与其他输出运算符保持一致，operator<<一般要返回它的ostream形参。<br>
##### Sales_data的输出运算符
🌰 
```cpp
ostream &operator<<(ostream &os, const Sales_data &item){
    os<<item.isbn()<<""<<item.units_sold<<""<<item.revenue<<""<<item.avg_price();
    return os;
}
```
##### 输出运算符尽量减少格式化操作
用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。
##### 输入输出运算符必须是非成员函数
假设输入输出运算符是某个类的成员，则它们也必须是istream或ostream的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。<br>
因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。**当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。**<br>
```cpp
class Sales_data{
    friend ostream &operator<<(ostream &os, const Sales_data &item);
    ...
}
```

```cpp
class String{
    friend ostream &operator<<(ostream &os, const String&);
}

ostream &operator<<(ostream &os, const String &s){
    char *c =  const_cast<char*>(s.c_str());
    while(*c)
        os<<*c++;
    return os;
}
```
### 重载输入运算符>>
@ 输入运算符的第一个形参是运算符将要读取的流的引用。<br>
@ 第二个形参时将要读入到的（非常量）对象的引用。<br>
@ 该运算符通常会返回某个给定流的引用。<br>
第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中<br>
##### Sales_data的输入运算符
吃个🌰 ：
```cpp
istream &operator>>(istream &is, Sales_data &item){
    double price; // 不需要初始化，因为我们将先读入数据到price，之后才使用它
    is>>item.bookNo >> item.units_sold >> price;
    if(is)
        item.revenue = item.units_sold * price;
    else
        item = Sales_data();// 输入失败就赋予默认值，确保对象处于正确的状态
    return is;
}
```
📒 输入运算符必须处理输入可能失败的情况，而输出运算符不需要<br>
##### 输入时的错误
@ 当流含有错误类型的数据时读取操作可能失败。<br>
@ 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败<br>
🏊‍♀️ 当读取操作发生错误时，输入运算符应该负责从错误中恢复。<br>
#### 标示错误
一些输入运算符需要做更多数据验证的工作。<br>
通常情况下，输入运算符只设置failbit。除此之外，设置eofbit表示文件耗尽，而设置badbit表示流被破坏。最好的方式是由IO标准库来标示这些错误。<br>
```cpp
class Sales_data{
    friend istream &operator>>(istream &is, Sales_data &item);
    ...
}
istream &operatr>>(istream &is,Sales_data &item){
    ...
}
```
### 算术和关系运算符
@ 算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。<br>
@ 因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。<br>
算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。<br>
如果定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：
```cpp
Sales_data operator+(const Sales_Data &lhs, const Sales_data &rhs){
    Sales_Data sum = lhs; 
    sum += rhs; // 将rhs加到sum中
    return sum;
}
```
与原来的add函数完全等价。<br>
💡 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。<br>
❓ 为什么调用operator+=来定义operator+比其他方法更有效? 因为用`operator+=`会避免使用一个临时对象，而使得更有效。<br>
#### 相等运算符
通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。
```cpp
bool operator==(const Sales_data &lhs, const Sales_data &rhs){
  return lhs.item == rhs.item && ...
}
```
几个设计原则：<br>
@ 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数：因为用户肯定希望能使用==比较对象，所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了==运算符之后也更容易使用标准库容器和算法。<br>
@ 如果类定义了operator==， 则运算符应该能判断一组给定的对象中是否含有重复数据。<br>
@ 通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和b==c都为真，则a==c也应该为真。<br>
@ 如果类定义了operator==，则这个类也应该定义operator!=。对于用户来说，当他们能使用==时肯定也希望能使用!=，反之亦然。<br>
@ 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符只是调用那个真正工作的运算符。<br>
💡 如果某个类在逻辑上有相等的含义，则该类应该定义operator==。这样做可以使得用户更统一使用标准库算法来处理这个类。<br>
#### 关系运算符
定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator会比较有用。<br>
通常情况下关系运算符应该<br>
1. 定义顺序关系，令其与关联容器中对关键字的要求一致。<br>
2. 如果类同时也含==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的，那么一个对象应该<另外一个。<br>
对于Sales_data类来说，不存在一种逻辑可靠的<定义。这个类不定义<运算符也许更好。<br>
💡 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当 且仅当<的定义和==产生的结果一致时才定义<运算符。<br>
### 赋值运算符
之前已经介绍过拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象<br>
🌰 ： 在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。
```cpp
vector<string> v;
v = {"a","b"...};
```
同样可以把这个运算符添加到StrVec类中
```cpp
class StrVec{
  public:
  StrVec &operator=(std::initializer_list<std::string>);
  ...
};
```
为了与内置类型的赋值运算符保持一直（也与我们已经定义的拷贝赋值和移动赋值运算符一致），这个新的赋值运算符将返回其左侧运算对象的引用。<br>
```cpp
StrVec &StrVec::operator=(initializer_list<string> il){
  // alloc_n_copy 分配内存空间并从给定范围内拷贝元素
  auto data = alloc_n_copy(il.begin(),il.end());
  free();   //销毁对象中的元素并释放内存空间
  elements = data.first; //更新数据成员使其指向新空间
  first_free = cap = data.second;
  return *this; // 返回其左侧运算对象的引用。
}
```
相同：这个和拷贝赋值及移动运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创建一片新空间。<br>
不同：这个运算符无需检查对象向自身的赋值，这是因为它的形参`initializer_list<string>`确保il与this所指的不是同一个对象。<br>
❕**我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。**<br>
#### 复合赋值运算符
复合赋值运算符不非得是类的成员，不过我们还是倾向于把包含复合赋值在内的所有赋值运算都定义在类的内部。<br>
为了与内置类型的符合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。
```cpp
// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针
// 假定两个对象表示的是同一本书
Sales_data& Sales_data::operator+=(const Sales_data &rhs){
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this;
}
```
@ 两类，赋值与复合赋值运算符都应该返回左侧运算对象的引用。<br>
### 下标运算符
表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。<br>
📒 下标运算符必须是成员函数。<br>
我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。<br>
💡 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。<br>
```cpp
class StrVec{
  public:
  std::string& operator[](std::size_t n){
    return elements[n];
  }
  const std::string& operator[](std::size_t n) const {
    return elements[n];
  }
  private:
  std::string *elements; //指向数组首元素的指针。
}
```
怎么用？？？（黑人问好脸）<br>
假设svec是一个StrVec对象
```cpp
const StrVec cvec = svec;
if(svec.size() && svec[0].empty()){
  svec[0] = "zero";  // 🙆 下标运算符返回string 的引用
  cvec[0] = "zip"; // 🙅 对cvec取下标返回的是常量引用
}
```
这个跟匹配的const有关系！
### 递增和递减运算符
在迭代器类中通常会实现递增运算符(++)和递减(--)运算符，这两种运算符使得类可以在元素的序列中前后移动。C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。<br>
为类定义两个版本的递增递减运算符（因为前置，um...后置）。<br>
#### 定义前置递增/递减运算符
```cpp
class StrBlobPtr{
  public:
  // 递增和递减运算符
  StrBlobPtr& operator++();
  StrBlobPtr& operator--();
  ...
}
```
💡 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。<br>
工作机理：<br>
首先调用check函数检验StrBlobPtr是否有效，如果是，接着检查给定的索引值是否有效。如果check函数没有抛出异常，则运算符返回对象的引用。<br>
在递增运算符的例子中，我们把curr的当前值传递给check函数。如果这个值小于vector的大小，则check正常返回；否则，如果curr已经到达了vector的末尾，check将抛出异常：<br>
```cpp
// 前置版本： 返回递增/递减运算对象的引用
StrBlobPtr& StrBlobPtr::operator++(){
  // 如果curr已经指向了容器的尾后位置，则无法递增它
  check(curr,"increment past end of StrBlobPtr");
  ++ curr; // 将curr在当前状态下向前移动一个元素
  return *this;
}
```
```cpp
// 前置版本： 返回递增/递减运算对象的引用
StrBlobPtr& StrBlobPtr::operator++(){
  // 如果curr是0，则继续递减它将产生一个无效下标
  -- curr; // 将curr在当前状态下向后移动一个元素
  check(curr,"increment past end of StrBlobPtr");
  return *this;
}
```
#### 区分前置和后置运算符
要想同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。<br>
为了解决这个问题，后置版本接受一个**额外的（不被使用）int类型的形参。**当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。<br>
这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。<br>
```cpp
class StrBlobPtr{
  public:
  // 递增和递减运算符
  StrBlobPtr operator++(int); // 后置版本
  StrBlobPtr operator--(int);
}
```
💡 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。<br>
```cpp
StrBlobPtr StrBlobPtr::operator++(int){
  // 此处无需检查有效性，调用前置递增运算时才需要检查
  StrBlobPtr ret = *this; // 记录当前的值
  ++*this; // 向前移动一个元素，前置++需要检查递增的有效性
  return ret; // 返回之前的记录的状态
}
```
```cpp
StrBlobPtr StrBlobPtr::operator--(int){
    // 此处无需检查有效性，调用前置递减运算时才需要检查
  StrBlobPtr ret = *this; // 记录当前的值
  --*this; // 向后移动一个元素，前置--需要检查递减的有效性
  return ret; // 返回之前的记录的状态
}
```
@ 无须为int命名。<br>
#### 显式地调用后置运算符
调用要为整形参数传递一个值。<br>
```cpp
StrBlobPtr p(a); // p指向a1中的vector
p.operator++(0); // 后置
p.operator++(); // 前置
```
❓ 为什么不定义const版本的递增和递减运算符？<br>
因为递增和递减会改变对象本身，所以定义const版本毫无意义<br>
### 成员访问运算符
在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(->)。<br>
```cpp
class StrBlobPtr{
  public:
  std::string& operator*()const{
    auto p = check(curr, "dereference past end");
    return (*p)[curr]; 
    // (*p) 是对象所指的vector
  }
  std::string* operator->()const{
    // 将实际工作委托给解引用运算符
    return & this->operator*();
  }
  ...
}
```
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果的元素的地址。<br>
📒 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。<br>
⚠️ 我们将这两个运算符定义成了const成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变`StrBlobPtr`对象的状态。同时，它们的返回值分别是非常量`string`的引用或指针，因为一个StrBlobPtr只能绑定到非常量的StrBlob对象。<br>
用法
```cpp
StrBlob a1 = {"hi","wolf"};
StrBlobPtr p(a1);
*p = "okey";
cout << p->size() << endl; // 首元素的大小
cout << (*p).size() << endl; // 等价p->size()
```
#### 对箭头运算符返回值的限定
和大多数其他运算符一样（尽管这样做不太好），我们能令operator*完成任何我们指定的操作。箭头运算符则不是，它永远不会丢掉成员访问这个最基本的含义。<br>
当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，**而箭头获取成员这一事实则永远不变。**<br>
对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator->的类的对象。根据point类型的不同，point->mem分别等价于
```cpp
(*point).mem; // point是一个内置的指针类型
point.operator()->mem; // point是类的一个对象
```
除此之外，代码都将发生错误。point->mem的执行过程如下所示：<br>
@ 如果point是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem。首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。<br>
@ 如果point是定义了operator->的类的一个对象，则我们使用point.operator->()的结果来获取mem。其中如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的operator->()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。<br>
📒 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。<br>
❓ 定义一个类令其含有指向StrBlobPtr对象的指针，为这个类定义重载的箭头运算符。<br>
```cpp
class StrBlobPtr;
class StrBlobPtr_pointer{
  public:
  StrBlobPtr_pointer() = default;
  StrBlobPtr_pointer(StrBlobPtr* p):pointer(p){}
  StrBlobPtr& operator*();
  StrBlobPtr* operator->();
  private:
  StrBlobPtr* pointer = nullptr;
}
```
### 函数调用运算符
如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。<br>
举个🌰 ：
struct absInt
