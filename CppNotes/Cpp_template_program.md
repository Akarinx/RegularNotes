# 模版与泛型编程
面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况（动态绑定）；而泛型编程中，在编译时就能获知类型了。<br>
其实，容器、迭代器和算法都是泛型编程的🌰 。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。**当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。** <br>
例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型的定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。<br>
**模版是泛型编程的基础。**<br>

模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，**将蓝图转换为特定的类或函数** 。**这种转换发生在编译时**。<br>
### 定义模版
#### 1. 函数模版
定义一个通用的 **函数模版(function template)** ,而不是每个类型都定义一个新函数。一个函数模版就是一个公式，可用来生成针对特定类型的函数版本。
```cpp
template <typename T> int compare(const T &v1, const T &v2){
  ...
}
```
模版定义以关键字template开始，后面跟一个 **模版参数列表(template parameter list)**，这是一个逗号分割的一个或多个 **模版参数(template parameter)** 的列表，用<>包围起来。<br>
📒 模版参数列表不能为空<br>
模版参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化它们。 **在运行时，调用者提供实参来初始化形参。**<br>
##### 实例化函数模版
当我们调用一个函数模版时，编译器（通常）用函数实参来为我们推断模版实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模版参数T的类型。
```cpp
cout << compare(1,0) << endl; // T 为int
vector<int> vec1{1,2,3}, vec2{3,4,5};
cout << compare(vec1, vec2) << endl; // T 为vector<int>
```
##### 模版类型参数
我们的compare函数有一个模版 **类型参数（type parameter）**。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：
```cpp
// ⭕️ 返回类型和参数类型相同
template <typename T> T foo(T* p){
  T tmp = *p; // tmp 的类型将是指针p指向的类型
  // ...
  return tmp;
}
```
类型参数前必须使用关键字class或typename：
```cpp
// ⭕️ 在模版参数列表中，typename和class没有什么不同
template<typename T, class U> calc(const T&, const U&);
```
##### 非类型模版参数


