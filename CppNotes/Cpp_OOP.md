# 面向对象程序设计
面向对象在很多语言都用得比较多。<br>
面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。在class那一章节，已经介绍了数据抽象的知识，这次我们介绍继承和动态绑定。<br>
继承和动态绑定对程序的编写有两方面的影响：<br>
a.我们可以更容易地定义与其他类相似但不完全相同的新类；<br>
b.在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。<br>
### OOP:概述
面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。<br>
通过使用 **数据抽象** ，我们可以将类的接口与实现分离；<br>
使用 **继承** ，可以定义相似的类型并对其相似关系建模；<br>
使用 **动态绑定** ，可以在一定程度上忽略类似的区别，而以统一的方式使用它们的对象。<br>
##### 继承
**通过继承(inheritance)联系在一起的类构成一种层次关系。**<br>
通常在层次关系的根部有一个 **基类（base class）**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为 **派生类（derived class）**<br>
基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。<br>
在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为 **虚函数（virtual function）**。
```cpp
class Quote{
  public:
  std::string isbn() const;
  virtual double net_price(std::size_t n) const;
}
```
派生类必须通过使用 **类派生列表(class derivation list)** 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：
```cpp
class Bulk_quote:public Quote{
  public:
  double net_price(std::size_t) const override;
}
```
因为Bulk_quote在它的派生列表中使用了public关键字，**因此我们完全可以把Bulk_quote的对象当成Quote的对象来使用。**<br>
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上`virtual`关键字，但是并不是非得这么做。**C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个`override`关键字。**<br>
##### 动态绑定
通过使用 **动态绑定(dynamic binding)**，我们能用同一段代码分别处理`Quote`和`Bulk_quote`的对象。
```cpp
// 计算并打印销售给定数量的某种书籍所得费用
double print_total(ostream &os,const Quote &item, size_t n){
  // 根据传入item形参的对象类型调用Quote::net_price
  // 或者Bulk_quote::net_price
  double ret = item.net_price(n);
  os<< ...
}
```
动态绑定有时又称为 **运行时绑定(run-time binding)**<br>
📒 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。<br>
### 定义基类和派生类
#### 定义基类
```cpp
class Quote{
  public:
  Quote() = default;
  Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
  std::string isbn() const { return bookNo; }
  // 返回给定数量的书籍的销售总额
  // 派生类负责改写并使用不同的折扣计算算法
  virtual double net_price(std::size_t n) const { return n*price; }
  virtual ~Quote() = default; // 对析构函数进行动态绑定
  private:
  std::string bookNo;
  protected:
  double price = 0.0;
}
```
记住作为继承关系中根节点通常会定义一个虚析构函数。<br>
📒 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。<br>
##### 成员函数与继承
派生类需要对虚函数这些操作提供自己的新定义以 **覆盖(override)** 从基类继承而来的旧定义。<br>
在C++语言中，基类必须将它的两种成员函数区分开来：<br>
a. 一种是基类希望其派生类进行覆盖的函数（常常将其定义为虚函数(virtual)，当我们使用指针或引用调用虚函数时，该调用将被动态绑定。） <br>
b. 基类希望派生类直接继承而不要改变的函数。<br>
基类通过在其成员函数的声明语句之前加上关键字`virtual`使得该函数执行动态绑定。<br>
@ 任何构造函数之外的非静态函数都可以是虚函数。<br>
@ 关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义。<br>
@ 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没有被声明为虚函数，则 **其解析过程发生在编译时而非运行时。**<br>
##### 访问控制与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。（和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。）<br>
不过在某些时候，基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用 **受保护的(protected)** 访问运算符说明这样的成员。<br>
❓ 什么是虚成员？<br>
对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。<br>
❓ protected 访问说明符与private有何区别？<br>
@ protected:基类和其派生类还有友元可以访问。<br>
@ private:只有基类本身和友元可以访问<br>
#### 定义派生类
派生类必须通过使用 **类派生列表(class derivation list)** 明确指出它是从哪个（哪些）基类继承而来的。<br>
**public、protected和private。**<br>
派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的Bulk_quote类必须包含一个net_price成员：
```cpp
class Bulk_quote:public Quote{
  public:
  Bulk_quote() = default;
  Bulk_quote(const std::string&,double,std::size_t,double);
  // 覆盖基类的函数版本以实现基于大量购买的折扣政策
  double net_price(std::size_t) const override;
  private:
  std::size_t min_qty = 0; // 适用折扣政策的最低购买量
  double discount = 0.0; // 以小数表示折扣额
};
```
我们能将公有派生类型的对象绑定到基类的引用或指针上。<br>
大多数类都只继承自一个类，这种形式的继承被称作“单继承”，它构成了本章的主题。<br>
##### 派生类中的虚函数
派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。<br>
派生类可以在它覆盖的函数前使用`virtual`关键字，但不是非得这么做。<br>
在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。<br>
##### 派生类对象及派生类向基类的类型转换
一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素：它从Quote继承而来的bookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。<br>
因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。<br>
甘难明，举个🌰咯
```cpp
Quote item; // 基类对象
Bulk_quote bulk; // 派生类对象
Quote *p = &item; // p 指向Quote对象
p = &bulk; // p指向bulk的Quote部分
Quote &r = bulk; // r绑定到bulk的Quote部分
```
这种转换通常称之为 **派生类到基类（derived-to-base）**类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。<br>
意味着，我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；<br>
也可以把派生类对象的指针用在需要基类指针的地方。<br>
##### 派生类构造函数
尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。<br>
📒 每个类控制它自己的成员初始化过程。<br>
派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。<br>
**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。**<br>
##### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员
```cpp
double Bulk_quote::net_price(size_t cnt) const{
  if(cnt >= min_qty)
      return cnt * (1-discount)*price;
  else
  return cnt * price;
}
```
目前只需要了解派生类的作用域嵌套在基类的作用域之内。<br>
**关键概念：遵循基类的接口**<br>
每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。<br>
因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。<br>
##### 继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中 **只存在该成员的唯一定义** 。不论从基类中派生出来多少个派生类，对于 **每个静态成员来说都只存在唯一的实例。**<br>
```cpp
class Base{
  public:
  static void statmem();
};
class Derived:public Base{
  void f(const Derived&);
};
```
**静态成员遵循通用的访问控制规则，** 如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它
```cpp
void Derived::f(const Derived &derived_obj){
  Base::statmem(); // ☑️ ：Base定义了statmem
  Derived::statmem(); // ☑️ ：Derived继承了statmem
  // ☑️ ：派生类的对象能访问基类的静态成员
  derived_obj.statmem(); // 通过Derived对象访问
  statmem(); // 通过this对象访问
}
```
##### 派生类的声明
声明派生类
```cpp
class Bulk_quote:public Quote; // ❌ 派生列表不能在这里出现
class Bulk_quote; // ☑️ 
```
派生列表以及与定义有关的其他细节必须与类的主体一起出现。<br>
##### 被用作基类的类
如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明
```cpp
class Bulk_quote:public Quote{...}
```
派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。<br>
一个类是基类，同时它也可以是一个派生类。<br>
```cpp
class Base{ // ...}
class D1:public Base{ // ...}
class D2:public D1{ // ...}
```
Base是D1的 **直接基类（direct base）** ，同时是D2的 **间接基类（indirect base）** 。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。<br>
每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类又含有其基类的成员；以此类推直至继承链的顶端。<br>
总结： 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。<br>
##### 防止继承的发生
不希望其他类可以继承，C++新标准提供了一个关键字 `final`。<br>
```cpp
class NoDerived final{ //...} // 不作为基类
class Last final : public Base{ // ...} // 不能继承Last
```
#### 类型转换与继承
⚠️ **理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在**<br>
通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个 **可接受的const类型转换规则。** 存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用`Quote&`指向一个`Bulk_quote`对象，也可以把一个`Bulk_quote`对象的地址赋给一个`Quote*`<br>
可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。**该对象可能是基类的对象，也可能是派生类的对象。**<br>
📒 和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。<br>
##### 静态类型和动态类型
当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的 **静态类型(static type)** 与该表达式表示对象的 **动态类型(dynamic type)** 区分开来。❓表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。<br>
🌰 
```cpp
double ret = item.net_price(n);
```
我们知道item的静态类型是Quote&，它的动态类型则依赖于item绑定的实参，动态类型直到运行时调用该函数时才知道。如果我们传递一个`Bulk_quote`对象给`print_total`，则item的静态类型将与它的动态类型不一致。如前所述，item的静态类型是`Quote&`，而在此例中它的动态类型则是`Bulk_quote`。<br>
**如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致** 。例如，Quote类型的变量永远是一个Quote对象，我们无论如何都不能改变该变量对应的对象的类型。<br>
📒 基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。<br>
##### 不存在从基类向派生类的隐式类型转换......
之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。<br>
**不存在从基类向派生类的自动类型转换**
```cpp
Quote base;
Bulk_quote* bulkp = &base; // ❌ 不能将基类转换成派生类
Bulk_quote& bulkRef = base; // ❌ 不能将基类转换成派生类
```
试想一下，如果上述赋值合法，我们就会用bulkp或bulkRef访问base中本不存在的成员。<br>
##### ......在对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。<br>
初始化，执行构造函数；赋值操作。调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的const的版本的引用。<br>
因为以上构造，赋值接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则 **实际运行的赋值运算符也是基类中定义的那个** ，该运算符同样只能处理基类自己的成员。<br>
```cpp
Bulk_quote bulk; // 派生类对象
Quote item(bulk); // 使用Quote::Quote(const Quote&)构造函数
item = bulk; // 调用Quote::operator=(const Quote&)
```
当构造item时，运行Quote的拷贝构造函数。
⚠️ 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。<br>
❓ 静态类型和动态类型的定义<br>

关键概念：存在继承关系的类型之间的转换规则，三点<br>
@ 从派生类向基类的类型转换只对指针或引用类型有效。<br>
@ 基类向派生类不存在隐式类型转换<br>
@ 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。<br>
尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员。因此，我们通常能将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。<br>

### 虚函数
如前所述，在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。必须为每个虚函数提供定义，不管他是否被用到了，这是因为，编译器也无法确定到底会使用哪个虚函数。<br>
##### 对虚函数的调用可能在运行时才被解析
当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个。<br>
很难明咧！举个🌰 吧：
```cpp
Quote base("222222",20);
print_total(cout,base,10); // 这里就说明了绑定的动态类型到Quote版本，所以调用的是Quote::net_price
Bulk_quote derived('2222333',50,5,.19);
print_total(cout,derived,10); // 这里调用的就是Bulk_quote::net_price，解释同理
```
动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
```cpp
base = derived; // 把derived的Quote部分拷贝给base
base.net_price(20); // 调用Quote::net_price
```
当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。<br>
@ **C++的多态性**<br>
OOP的核心思想时 **多态性(polymorphism)** 。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。<br>
📒 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。<br>
##### 派生类中的虚函数
当我们在派生类中覆盖某个虚函数时，可以再一次使用`virtual`关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。<br>
同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回可以返回B* 而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型转换是可访问的。
```cpp
class B{
  virtual B* vribfun()
}
class D:public B{
  virtual D* virbfun()
}
```
基类中虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。<br>
##### final和override说明符
派生类如果定义了一个函数和一个基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。<br>
在调试中发现这种错误是很困难的。<br>
在新标准中我们可以使用`override`关键字来说明派生类中的虚函数。如果我们使用了`override`标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器会 **报错。**<br>
还能把某个函数指定为 `final`，如果我们已经把函数定义成`final`了，则之后任何尝试覆盖该函数的操作都将引发错误:
```cpp
struct D2:B{
  // 从B继承f2()和f3()，覆盖f1(int)
  void f1(int) const final; // 不允许后续的其他类覆盖f1(int)
}；
struct D3:D2{
  void f2(); // ☑️ 覆盖从间接基类B继承而来的f2
  void f1(int) const; // ❌ D2已经将f2声明成final
}
```
`final`和`override`说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型。<br>
##### 虚函数与默认实参
和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。<br>
换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。<br>
💡 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。<br>
##### 回避虚函数的机制
在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的
```cpp
// 强行调用基类定义的函数版本而不敢baseP的动态类型到底是什么
double undiscounted = baseP -> Quote::net_price(42);
```
该调用将在编译时完成解析。<br>
📒 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。<br>
⚠️ 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。<br>
```cpp
virtual void debug() const;
```
❓ 有必要将一个成员函数同时声明成 override 和 final 吗？为什么？<br>
有必要。override 的含义是重写基类中相同名称的虚函数，final 是阻止它的派生类重写当前虚函数。
### 抽象基类
##### 纯虚函数
**纯虚函数(pure virtual funciton)** 无须定义，通过在函数体的位置（即声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。<br> 
```cpp
// 用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
class Disc_quote:public Quote{
  public:
  Disc_quote() = default;
  Disc_quote(const std::string& book, double price, std::size_t qty, double disc):Quote(book,price),quantity(qty),discount(disc){}
  double net_price(std::size_t) const = 0;
  protected:
  std::size_t quantity = 0; // 折扣适用的购买量
  double discount = 0.0; // 表示折扣的小数值
}；
```
⚠️ 我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。<br>
##### 含有纯虚函数的类是抽象基类
含有（或者未经覆盖直接继承）纯虚函数的类是 **抽象基类（abstract base class）**。 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们 **不能（直接）创建一个抽象基类的对象**。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象，前提是这些类覆盖了net_price函数<br>
所以， **抽象基类，没有对象！**<br>
##### 派生类构造函数只构造它的直接基类
Bulk_quote继承Disc_quote
```cpp
// 当同一书籍的销量超过某个值时启用折扣
// 折扣的值是一个小于1的正的小数值，以此来降低正常销售价格
class Bulk_quote:public Disc_quote{
  public:
  Bulk_quote() = default;
  Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):Disc_quote(book,price,qty,disc){}
  // 覆盖基类中的函数版本以实现一种新的折扣策略
  double net_price(std::size_t) const override;
};
```
这个版本的Bulk_quote的直接基类是Disc_quote，间接基类是Quote。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。<br>
如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍然需要原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。先是Quote，然后Disc_quote，最后是Bulk_quote。<br>
**关键概念：重构**<br>
在Quote的继承体系增加Dsic_quote类是重构（refactoring)的一个典型示例。<br>
重构，负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。<br>
⚠️ 即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构（或以其它方式被改变），就意味着我们必须重新编译含有这些类的代码了。<br>
### 访问控制与继承
每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否 **可访问（accessible）**。
##### 受保护的成员 proteced
一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物。<br>
@ 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。<br>
@ 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。<br>
@ 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。**派生类对于一个基类对象中的受保护成员没有任何访问特权。**<br>
理解最后一个规则，举个🌰 ：
```cpp
class Base{
  protected:
  int prot_mem; // protected 成员
};
class Sneaky:public Base{
  friend void clobber(Sneaky&); // 能访问Sneaky::prot_mem
  friend void clobber(Base&); // 不能访问Base::prot_mem
  int j; // j默认是private
}；
// ☑️ clobber能访问Sneaky对象的private和protected成员
void clobber(Sneaky &s) { s.j = s.prot_mem = 0;}
// ❌ clobber不能访问Base的protected成员
void clobber(Base &b) { b.prot_mem = 0; }
```
派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；<br>
对于普通的基类对象中的成员不具有特殊的访问权限。<br>
##### 公有、私有和受保护继承
某个类对其继承未来的成员的访问权限受到两个因素 影响：一是在基类中该成员的访问说明符，二是在派生类列表中的访问说明符。
```cpp
class Base{
  public:
     void pub_mem();
  protected:
     void pro_mem();
  private:
     void pri_mem();
};
struct Pub_Derv:public Base{
  // 仅可访问public
};
struct Pro_Derv:protected Base{

};
struct Pri_Derv:private Base{
  // private不影响派生类的访问权限
}
```
对基类成员的访问权限只与基类中的访问说明符有关。Pub_Derv和Pri_ Derv都能访问受保护的成员pro_mem，同时它们都不能访问私有成员pri_mem。<br>
派生类说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限
```cpp
Pub_Derv d1; // 继承自Base成员是public
Pri_Derv d2; // 继承自Base的成员是private
d1.pub_mem(); // ☑️
d2.pub_mem(); // ❌
```
在Pri_Derv中，Base的成员是私有的，因此类的用户不能调用pub_mem。<br>
派生类说明符还可以控制继承自派生类的新类的访问权限
```cpp
struct Derived_from_Publi:public Pub_Derv{
  // ✅ 仍然是protected
  int use_base() { return prot_mem; }
};
struct Derived_from_Private:public Pri_Derv{
  // ❌ Base::pro_mem在Pri_Derv中是private的
  int use_base() { return prot_mem; }
}
```
Pro_Derv，受保护继承，Base中的所有公有成员在新定义的类中都是受保护的。Pro_Derv的用户（对象）不能访问pub_mem，但是Pro_Derv的成员和友元可以访问那些继承而来的成员。<br>
##### 派生类向基类转换的可访问性
派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B:<br>
@ 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。<br>
@ 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。<br>
@ 如果D继承B的方式时公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。<br>
💡 对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之不行。<br>
**关键概念：类的设计与受保护的成员**<br>
##### 友元与继承
就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。
```cpp
class Base{
  // 添加friend声明，其他成员与之前的版本一致
  friend class Pal; // Pal在访问Base的派生类时不具有特殊性
};
class Pal{
  public:
  int f(Base b){ return b.pro_mem; } // ✔️ Pal是Base的友元
  // 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
  int f3(Sneaky s){ return s.pro_mem; }// ✔️ Pal是Base的友元
};
```
Pal是Base的友元，所以Pal能够访问Base对象的成员，这种可访问性包括了Base对象内嵌在其派生类对象中的情况。<br>
当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力。<br>
```cpp
// D2对Base的protected和private成员不具有特殊的访问能力
class D2:public Pal{
  public:
  int mem(Base b){ return b.pro_mem; } // ❌ 友元关系不能继承
}
```
📒 不能继承友元关系；每个类负责控制各自成员的访问权限。<br>
##### 改变个别成员的可访问性
有时我们需要改变派生类继承的某个名字的访问级别，听过使用using声明可以达到这一目的。<br>
```cpp
class Base{
  public:
  std::size_t size() const { return n; }
};
class Derived:private Base{ // ⚠️ private继承
  public:
   // 保持对象尺寸相关的成员的访问级别
    using Base::size;
  protected:
    using Base::n;
}
```
因为Derived使用了私有继承，所以继承而来的成员size和n(在默认情况下)是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。改变之后，Derived的用户将可以使用size成员，而Derived的派生类将能使用n。<br>
通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。也就是说，如果一条using声明语句出现在类的private部分，则该名字只能被类的成员和友元访问；protected，则该名字对于成员、友元和派生类是可访问的；public，类的所有用户都能访问它。<br>
📒 派生类只能为那些它可以访问的名字提供using声明。<br>
##### 默认的继承保护级别
默认情况下，使用`class`关键字定义的派生类是私有继承的；而使用`struct`关键字定义的派生类是公有继承的:<br>
```cpp
class Base{}
struct D1:Base{ } // 默认public继承
class D2:Base{} // 默认private继承
```
唯一的差别就是默认成员访问说明符及默认派生访问说明符<br>

### 继承中的类作用域
每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。**如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。**<br>
类似冒泡查找，不断往上查找。<br>
##### 在编译时进行名字查找
一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。
```cpp
class Disc_quote:public Quote{
  public:
  std::pair<size_t,double> discount_policy() const{ return {quantity,discount};}
  ...
}
```
pair的返回值是一对的。<br>
我们只能通过Dsic_quote及其派生类的对象、引用或指针使用discount_policy:
```cpp
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // 静态类型与动态类型一致
Quote *itemP = &bulk; // 静态类型与动态类型不一致
bulkP->discount_policy(); // ✅ bulkP的类型是Bulk_quote*
itemP->dicount_policy(); // ❌ itemP的类型是Quote*
```
尽管在bulk中确实含有一个名为discount_policy的成员，但是该成员对于itemP却是不可见的。itemP的类型是Quote的指针，意味着对discount_policy的搜索将从Quote开始。显然Quote不包含名为discount_policy的成员，所以我们无法通过Quote的对象、引用或指针调用discount_policy。<br>
##### 名字冲突与继承
和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字， **此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字**。
```cpp
struct Base{
  Base():mem(0){}
  protected:
  int mem;
};
struct Derived:Base{ // 默认public继承
  Derived(int i):mem(i){} // 用i初始化Derived::mem
  // Base::mem进行默认初始化
  int get_mem() { return mem; } // 返回Derived::mem 覆盖基类Base的mem
  protected:
  int mem; // 隐藏基类中的mem
}
```
📒 派生类的成员将隐藏同名的基类成员<br>
##### 通过作用域运算符来使用隐藏的成员
我们可以通过作用域运算符来使用一个被隐藏的基类成员
```cpp
struct Derived:Base{
  int get_base_mme(){ return Base::mem;}
  ...
}
```
💡 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。<br>
**关键概念：名字查找与继承**<br>
@ 首先确定静态类型<br>
@ 静态类型中查找
@ 检查虚函数还是非虚函数
##### 一如往常，名字查找先于类型检查
如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉
```cpp
struct Base{
  int memfcn();
};
struct Derived:Base{
  int memfcn(int); // 隐藏基类的memfcn
};
Derived d; Base b;
b.memfcn(); // 调用Base::memfcn
d.memfcn(10); // 调用Derived::memfcn
d.memfcn(); // ❌ 
d.Base::memfcn(); // 调用Base::memfcn
```
##### 虚函数与作用域
假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。
```cpp
class Base{
  public:
  virtual int fcn();
};
class D1:public Base{
  public:
  // 隐藏基类的fcn，这个fcn不是虚函数
  // D1继承了Base::fcn() 的定义
  int fcn(int); // 形参列表与Base中的fcn不一致
  virtual void f2(); // 是一个新的虚函数，在Base中不存在
};
class D2:public D1{
  public:
  int fcn(int); // 是一个非虚函数，隐藏了D1::fcn(int)
  int fcn();  // 覆盖了Base的虚函数fcn
  void f2();  // 覆盖了D1的虚函数f2
}
```
##### 通过基类调用隐藏的虚函数
```cpp
Base bobj; D1 d1obj;D2 d2obj;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
bp1->fcn(); // 虚调用，将在运行时调用Base::fcn
bp2->fcn(); // 虚调用，将在运行时调用Base::fcn
bp3->fcn(); // 虚调用，将在运行时调用D2::fcn
D1 *d1p = &d1obj;D2 *d2p = &d2obj;
bp2->f2(); // ❌ Base中没有名为f2的成员
d1p->f2(); // 虚调用，将在运行时调用D1::f2
d2p->f2(); // 虚调用，将在运行时调用D2::f2
```
前三条调用语句是通过基类的指针进行的，因为fcn是虚函数，所以编译器产生的代码将在运行时确定使用虚函数的哪个版本。判断的依据是该指针所绑定对象的真实类型。<br>
调用语句中，在bp2的例子中，实际绑定的对象是D1类型，而D1并没有覆盖那个不接受实参的fcn，所以通过bp2进行的调用将在运行时解析为Base定义的版本。<br>
接下来的三条调用语句是通过不同类型的指针进行的，每个指针分别指向继承体系中的一个类型。因为Base类中没有f2()，所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事。<br>
##### 覆盖重载的函数
和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。<br>
**为重载成员提供一条using声明语句，就无须覆盖基类中的每一个重载版本**。using 声明语句指定一个名字而 **不指定形参列表** ，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。<br>
类内using声明的一般规则同样适用于重载函数的名字，基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。<br>
### 构造函数与拷贝控制
创建、拷贝、赋值和销毁。如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器将为它合成一个版本。当然这个合成版本也可以定义成被删除的函数。<br>
#### 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义的一个虚析构函数，这样我们就能动态分配继承体系中的对象了。<br>
如前所述，当我们`delete`一个动态分配的对象的指针时 **将执行析构函数**。如果该指针指向继承体系中的某个类型，则有可能出现 **指针的静态类型与被删除对象的动态类型不符** 的情况。<br>
