# 面向对象程序设计
面向对象在很多语言都用得比较多。<br>
面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。在class那一章节，已经介绍了数据抽象的知识，这次我们介绍继承和动态绑定。<br>
继承和动态绑定对程序的编写有两方面的影响：<br>
a.我们可以更容易地定义与其他类相似但不完全相同的新类；<br>
b.在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。<br>
### OOP:概述
面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。<br>
通过使用 **数据抽象** ，我们可以将类的接口与实现分离；<br>
使用 **继承** ，可以定义相似的类型并对其相似关系建模；<br>
使用 **动态绑定** ，可以在一定程度上忽略类似的区别，而以统一的方式使用它们的对象。<br>
##### 继承
**通过继承(inheritance)联系在一起的类构成一种层次关系。**<br>
通常在层次关系的根部有一个 **基类（base class）**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为 **派生类（derived class）**<br>
基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。<br>
在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为 **虚函数（virtual function）**。
```cpp
class Quote{
  public:
  std::string isbn() const;
  virtual double net_price(std::size_t n) const;
}
```
派生类必须通过使用 **类派生列表(class derivation list)** 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：
```cpp
class Bulk_quote:public Quote{
  public:
  double net_price(std::size_t) const override;
}
```
因为Bulk_quote在它的派生列表中使用了public关键字，**因此我们完全可以把Bulk_quote的对象当成Quote的对象来使用。**<br>
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上`virtual`关键字，但是并不是非得这么做。**C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个`override`关键字。**<br>
##### 动态绑定
通过使用 **动态绑定(dynamic binding)**，我们能用同一段代码分别处理`Quote`和`Bulk_quote`的对象。
```cpp
// 计算并打印销售给定数量的某种书籍所得费用
double print_total(ostream &os,const Quote &item, size_t n){
  // 根据传入item形参的对象类型调用Quote::net_price
  // 或者Bulk_quote::net_price
  double ret = item.net_price(n);
  os<< ...
}
```
动态绑定有时又称为 **运行时绑定(run-time binding)**<br>
📒 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。<br>
### 定义基类和派生类
#### 定义基类
```cpp
class Quote{
  public:
  Quote() = default;
  Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
  std::string isbn() const { return bookNo; }
  // 返回给定数量的书籍的销售总额
  // 派生类负责改写并使用不同的折扣计算算法
  virtual double net_price(std::size_t n) const { return n*price; }
  virtual ~Quote() = default; // 对析构函数进行动态绑定
  private:
  std::string bookNo;
  protected:
  double price = 0.0;
}
```
记住作为继承关系中根节点通常会定义一个虚析构函数。<br>
📒 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。<br>
##### 成员函数与继承
派生类需要对虚函数这些操作提供自己的新定义以 **覆盖(override)** 从基类继承而来的旧定义。<br>
在C++语言中，基类必须将它的两种成员函数区分开来：<br>
a. 一种是基类希望其派生类进行覆盖的函数（常常将其定义为虚函数(virtual)，当我们使用指针或引用调用虚函数时，该调用将被动态绑定。） <br>
b. 基类希望派生类直接继承而不要改变的函数。<br>
基类通过在其成员函数的声明语句之前加上关键字`virtual`使得该函数执行动态绑定。<br>
@ 任何构造函数之外的非静态函数都可以是虚函数。<br>
@ 关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义。<br>
@ 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没有被声明为虚函数，则 **其解析过程发生在编译时而非运行时。**<br>
##### 访问控制与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。（和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。）<br>
不过在某些时候，基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用 **受保护的(protected)** 访问运算符说明这样的成员。<br>
❓ 什么是虚成员？<br>
对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。<br>
❓ protected 访问说明符与private有何区别？<br>
@ protected:基类和其派生类还有友元可以访问。<br>
@ private:只有基类本身和友元可以访问<br>
#### 定义派生类
派生类必须通过使用 **类派生列表(class derivation list)** 明确指出它是从哪个（哪些）基类继承而来的。<br>
**public、protected和private。**<br>
派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的Bulk_quote类必须包含一个net_price成员：
```cpp
class Bulk_quote:public Quote{
  public:
  Bulk_quote() = default;
  Bulk_quote(const std::string&,double,std::size_t,double);
  // 覆盖基类的函数版本以实现基于大量购买的折扣政策
  double net_price(std::size_t) const override;
  private:
  std::size_t min_qty = 0; // 适用折扣政策的最低购买量
  double discount = 0.0; // 以小数表示折扣额
};
```
我们能将公有派生类型的对象绑定到基类的引用或指针上。<br>
大多数类都只继承自一个类，这种形式的继承被称作“单继承”，它构成了本章的主题。<br>
##### 派生类中的虚函数
派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。<br>
派生类可以在它覆盖的函数前使用`virtual`关键字，但不是非得这么做。<br>
在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。<br>
##### 派生类对象及派生类向基类的类型转换
一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素：它从Quote继承而来的bookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。<br>
因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。<br>
甘难明，举个🌰咯
```cpp
Quote item; // 基类对象
Bulk_quote bulk; // 派生类对象
Quote *p = &item; // p 指向Quote对象
p = &bulk; // p指向bulk的Quote部分
Quote &r = bulk; // r绑定到bulk的Quote部分
```
这种转换通常称之为 **派生类到基类（derived-to-base）**类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。<br>
意味着，我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；<br>
也可以把派生类对象的指针用在需要基类指针的地方。<br>
##### 派生类构造函数
尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。<br>
📒 每个类控制它自己的成员初始化过程。<br>
派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。<br>
**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。**<br>
##### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员
```cpp
double Bulk_quote::net_price(size_t cnt) const{
  if(cnt >= min_qty)
      return cnt * (1-discount)*price;
  else
  return cnt * price;
}
```
目前只需要了解派生类的作用域嵌套在基类的作用域之内。<br>
**关键概念：遵循基类的接口**<br>
每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。<br>
因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。<br>
##### 继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中 **只存在该成员的唯一定义** 。不论从基类中派生出来多少个派生类，对于 **每个静态成员来说都只存在唯一的实例。**<br>
```cpp
class Base{
  public:
  static void statmem();
};
class Derived:public Base{
  void f(const Derived&);
};
```
**静态成员遵循通用的访问控制规则，** 如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它
```cpp
void Derived::f(const Derived &derived_obj){
  Base::statmem(); // ☑️ ：Base定义了statmem
  Derived::statmem(); // ☑️ ：Derived继承了statmem
  // ☑️ ：派生类的对象能访问基类的静态成员
  derived_obj.statmem(); // 通过Derived对象访问
  statmem(); // 通过this对象访问
}
```
##### 派生类的声明
声明派生类
```cpp
class Bulk_quote:public Quote; // ❌ 派生列表不能在这里出现
class Bulk_quote; // ☑️ 
```
派生列表以及与定义有关的其他细节必须与类的主体一起出现。<br>
##### 被用作基类的类
如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明
```cpp
class Bulk_quote:public Quote{...}
```
派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。<br>
一个类是基类，同时它也可以是一个派生类。<br>
```cpp
class Base{ // ...}
class D1:public Base{ // ...}
class D2:public D1{ // ...}
```
Base是D1的 **直接基类（direct base）** ，同时是D2的 **间接基类（indirect base）** 。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。<br>
每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类又含有其基类的成员；以此类推直至继承链的顶端。<br>
总结： 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。<br>
##### 防止继承的发生
不希望其他类可以继承，C++新标准提供了一个关键字 `final`。<br>
```cpp
class NoDerived final{ //...} // 不作为基类
class Last final : public Base{ // ...} // 不能继承Last
```
#### 类型转换与继承
⚠️ **理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在**<br>
