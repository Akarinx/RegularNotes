
# C++primer变量与基本类型&字符串、向量和数组<br>
其实C++这一门语言很好地阐释了计算机系统语言的一种，学了C++ 其他编程语言都会变得很简单，很容易上手，其实我也想在最近做一下C++ primer的总结，老生常谈，学语言最重要是要学会他的思想以及他赠送给你的思维，让你用新的思维去想一个问题。这段期间，每两个月做一次更新，主要就是摘录这本书的语句，咬文嚼字，并且实现里面的程序段代码，偶尔会夹杂一些算法的题目，基本上是刷leetcode的题目。<br>
## 一、变量与基本类型<br>
这一章节很基础，也很重要。其实这一章节基本上是所有语言都该有的介绍，变量与基本类型，你必须知道基本内置类型的算术类型的尺寸，字节数，占位，才能计算出你设计的结构Struct是否满足你的使用而不溢出。其中更涉及到类型的转换，**类型转换**:对象的类型定义了对象能包含的数据与能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换为另一种相关类型。<br>
**字面值常量**： 0开头 8进制  OX开头十六进制<br>
在这里，着重讲一下变量，其实变量都会占用存储空间的，所以在声明一个变量要注意占用的空间。<br>
**变量**：  提供一个具名的、可供程序操作的存储空间。阐述一下：（C++中每个变量都有其数据类型，数据类型决定着变量所占空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。）<br>
**变量的定义**：基本形式 类型说明符 随后紧跟着由一个或多个变量名组成的列表，用逗号隔开这列表，最后分号结束。<br>
*举个栗子*：
    ```cpp 
           int sum,value=0; 
           Sales_item item;//Sales_item 是一种自定义类型，在后面的第七章会讲到这个如何定义！
           ```
讲到了初始化，其实初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。其实在声明的时候，变量没有指定初始值，系统都已经给这个变量赋值了！这叫**默认初始化**<br>
接下来是变量声明与定义的关系，**C++语言支持分离式编译机制**，这是为了允许把程序分割成若干个文件，每个文件可以被独立编译。同时，为了支持分离式编译，C++语言将声明与定义区分开来。**声明使得名字为程序所知，定义负责创建与名字关联的实体**。<（这句话很重要）<br>
*extern* 如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量 <br>
extern int i;//声明并不定义i<br>
int j;//声明并定义j<br>
*任何包含了显式初始化的声明即成定义！！！*<br>
*变量能且只能被定义一次，但是可以被多次声明*<br>
到这里其实你会觉得，变量和定义的区别好像并不重要，但实际上，如果要在多个文件中使用同一个变量，就必须将声明和定义分离，此时，变量的定义只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝不能重复定义。<br>

在这里也可以做一个知识的拓展：*C++是一种静态类型的语言 就是在编译阶段检查类型！检查类型的过程就叫做类型检查*<br>

前方高能！！！超级重点，以后看不看得懂程序就差这里了<br>
为了表示重要性，我特意放大了字号并bold复合类型：**指针，引用，地址符，解引用**<br>


**复合类型**：基于其他类型定义的类型<br>
引用：为对象起的另外一个名字，引用类型引用另外一种类型，通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：<br>
```cpp
int ival = 1024

int &refVal = ival;//refVal 指向ival（是ival的另外一个名字）
```

这里有一段话，我要摘录下来，细细品味一下<br>

*一般在初始化变量时，初始值会被拷贝到新建的对象中。然而，定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。*<br>

引用即别名：其实引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。<br>

那么在定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的<br>
```cpp

refVal = 2;//赋值给ival<br>

int i = refVal; //将refVal的值赋给i<br>
```

为引用赋值，实际上是把值赋给了与引用绑定的对像。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值<br>
```cpp
int &refVal2 = refVal;
int i = refVal;
```
*因为引用本身不是一个对象，所以不能定义引用的引用。*<br>

*引用的定义不能与字面值或者某个表达式的计算结果绑定在一起。*<br>



## 指针<br>

**指针是指向另外一种类型的复合类型。** 与引用类似，指针也是想了对其他对象的间接访问，然而指针与引用又有很多不同点。<br>
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 <br>
2. 指针无须在定义时赋予初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。<br>

获取对象的地址<br>
```cpp
int ival = 42;

int *p = &ival;
```
指针的类型必须相互匹配。<br>

**指针的值**<br>

1. 指向一个对象 <br>
2.指向紧邻对象所占空间的下一个位置 <br>
3.空指针，意味着指针没有指向任何对象  <br>
4.无效指针，也就是上述情况之外的其他值(so smart)<br>

**利用指针访问对象**<br>
如果指针指向了一个对象，则允许使用解引用符（*）<br>
其实这里已经充分体现（*）是一复合类型<br>
```cpp
int ival = 42;
int *p = &ival;
cout<< *p;
```
如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值<br>
（解引用操作仅适用于那些确实指向了某个对象的有效指针）<br>
*空指针（nullptr) 不指向任何对象。（C++11 引入的标准）*<br>
*建议： 初始化所有指针*<br>
*给指针赋值就是令它存放一个新的地址，从而指向一个新的对象*<br>
```cpp
pi = &ival;<br>
*pi = 0;//ival的值被改变，指针pi的地址值并没有改变<br>
```
Void *指针 一种特殊的指针类型，可用于存放任意对象的地址。<br>
**理解复合类型的声明**<br>
int i = 1024, *p = &i, &r = i ;<br>
定义多个变量<br>
int* p1,p2; //p1 是指向int的指针，p2是int<br>
这里说明了int*，基本数据类型是int 而不是int*<br>
**指向指针的引用**<br>
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：<br>
```cpp
// int b;
// int &r = b;
int i = 42;
int *p ;//p是一个int整型指针<br>
int *&r = p;//r是一个对指针p的引用<br>
r=&i;//r 引用了一个指针，因此给r赋值&i就是令p指向i<br>
*r = 0;//解引用得到i。也就是p指向的对象，将i的值改为0
```
<br>
## const限定符<br>
有时候，我们希望定义这样一种变量，它的值不能改变。<br>
const int bufSize = 512<br>
const 对象一旦创建后其值就不能再改变，所以const 对象必须初始化。初始值可以是任意复杂的表达式：<br>
```cpp
const int i = get_size(); //运行时初始化<br>
const int j = 42; // 编译初始化<br>
const int k; // 错误： k是一个未经初始化的常量<br>
```
**初始化和const**<br>
对象的类型决定了其上的操作。<br>
默认状态下，const对象仅在文件内有效。<br>
某些时候我们只想在一个文件中定义const，而在其他多个文件中声明并使用它，所以对于const变量不管是声明还是定义都添加extern关键字。<br>
ex: extern const int bufSize = fcn(); //该常量在一个文件中定义并初始化，该常量能被其他文件访问。<br>
**const的引用**<br>
可以把引用绑定到const对象上，就像绑定到其他对象上，我们称之为对 常量的引用<br>
const int ci = 1024;<br>
const int &r1 = ci; // 引用及其对应的对象都是常量（这里说明一下，类型必须是匹配的，常量对常量，非常量对非常量<br>
**初始化和对const的引用**
引用的类型必须与其所引用对象的类型一致，但是两个例外：1. 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能转换成引用的类型即可。例如：<br>
```cpp
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 *2;// 这个就是表达式
```
对const的引用可能引用一个并非const的对象<br>
**指针与const**<br>
其实与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针 不能用于改变其所指对象的值。<br>
const double pi = 3.14;<br>
const double *ptr = &pi;<br>
一个例外情况，允许另一个指向常量的指针指向一个非常量对象：<br>
double dval = 3.14;<br>
ptr = &dval;(这里记住是指向！指向的是常量！）<br>
**const 指针**<br>
指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。<br>
常量指针必须初始化！！！而且一旦初始化完成，则它的值就不能再改变了。<br>
int *const curErr = &errNumb; //不变的是指针本身的值而非指向的那个值。<br>
const double pi = 3.14;<br>
const double *const piptr = &pi;//piptr是一个指向常量对象的常量指针<br>
**顶层const**<br>
这里有两个相互独立的问题需要看看  指针本身是不是常量以及    指针所指的是不是一个常量<br>
顶层const：指针本身是个常量<br>
底层const：指针所指的对象是一个常量<br>
```cpp
int i = 0;
int *const pi = &i; //顶层
const int ci = 42;//顶层
const int *p2 = &ci //底层
```
**constexpr和常量表达式**<br>
常量表达式是指值不会改变并且再编译过程就能得到计算结果的表达式。<br>
处理类型<br>
类型别名：
```cpp
typedef double wages;
typedef wages base,*p;
using SI = Sales_item;
```
**auto 类型说明符**<br>
auto item =val1+val2;<br>
一条声明语句只能有一个基本数据类型，所以该语句所有变量的初始基本数据类型都必须一样<br>
decltype类型指示符（选择并返回操作数的数据类型）int i = 1 ;decltype (i) x = 0;<br>
自定义数据结构（这项技能是一定必须要用到的）<br>
栗子：<br>
```cpp
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
} accum, trans,*salesptr;
```
*花括号包围形成一个新的作用域。类内部的名字必须是唯一的。类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少*<br>
**字符串、向量和数组**<br>
string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列<br>
命名空间的using声明<br>
```cpp
using namespace::name
```
一般来说，头文件不应包含using声明<br>
**标准库类型string**<br>
使用string类型必须首先包含string头文件<br>
```cpp
#include <string>
using std::string
定义和初始化string对象
    
string s1  //默认初始化，空串
string s2(s1) //s2是s1的一个副本
string s2=s1
string s3("value")
string s3="value" // （拷贝）
string s4(n,'c') // s4初始化为由连续n个字符c组成的串（直接）
```
**直接初始化和拷贝初始化**<br>
String对象上的操作<br>
一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。<br>
os<<s //将s写到输出流os中，返回os<br>
is>>s //从is中读取字符串赋值给s，字符串以空白分隔，返回is<br>
getline(is,s) //从is中读取一行赋值给s，返回is<br>
s.empty()<br>
s.size()<br>
s[n]<br>
s1+s2<br>
s1=s2<br>
s1==s2<br>
s1!=s2<br>
<,>=,<=,><br>
读写string对象<br>
string s1,s2;<br>
cin >> s1>>s2;<br>
cout << s1<<endl;<br>
读取未知数量的string对象<br>
string word;<br>
while(cin >> word)<br>
    cout<< word <<endl; //反复读取直至文件末尾<br>
string::size_type类型<br>
处理每个字符，使用基于范围的for语句<br>
```cpp
string s("hello world");
for(auto &c : s)
    c = toupper(c);
cout<< s << endl;
```cpp
使用下标执行迭代<br>
```
for(decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++index)
      s[index] = toupper(s[index])
```
**标准库类型vector**<br>
标准库类型vector 表示对象的集合，其中所有对象的类型都相同。 集合中的每个对象都有意个与之对应的索引，索引用于访问对象。<br>
```cpp
#include <vector>
using std::vector;
```
C++语言既有类模板，也有函数模板，其实vector是一个类模板<br>
模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。<br>
编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。<br>
例如<br>
```cpp
vector<int> ivec;
vector<Sales_item> Sales_vec;
vector<vector<string>> file;  //该向量的元素是vector对象
```
vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。<br>
定义与初始化vector对象<br>
```cpp
vector<T> v1;
vector<T> v2(v1)
vector<T> v3(n,val)
vector<T> v4(n)
vector<T> v5 {a,b,c,d...}
vector<T> v5 = {a,b,c,d,e,f...}
```
向vector对象中添加元素<br>
<br>
```cpp
vector <int> v2;
for(int i = 0;i!=100;++i)
    v2.push_back(i);
```
vector操作
```cpp
v.empty()
v.size()
v.push_back(t)
v[n]
v1 = v2
v1 = {a,b,c,...}
v1 == v2
v1 != v2
```
**使用迭代器(iterator)**<br>
*迭代器分为有效和无效，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置，其他情况都属于无效。*<br>
*使用迭代器 5.22*<br>
**begin & end**<br>
begin成员负责返回指向第一个元素的迭代器<br>
end成员则负责返回指向容器“ 尾元素的下一位置” 的迭代器。<br>
特殊情况下，如果容器为空，则begin 和 end返回的是同一个迭代器，都是尾后迭代器<br>
*iter //返回迭代其iter所指元素的引用<br>
iter->mem //解引用iter并获取该元素的名为mem的成员，等价 （*iter).mem<br>
++iter
--iter
举个例子使用迭代器<br>
```cpp
string s("something");
if(s.begin() != s.end()){
    auto it = s.begin();
    *it = toupper(*it);
}
```
将迭代器从一个元素移动到另外一个元素 523<br><br>
迭代器使用递增运算符来从一个元素移动到下一个元素<br>
```cpp
for(auto it = s.begin(); it != s.end()&&!isspace(*it);++it)
      *it = toupper(*it);//将当前字符改成大写形式
```
迭代器的使用比较有意思，在很多容器例如set,vector等，接下里会讲到容器及其使用，很多容器都有这一对迭代器，一般而言，迭代器都是成对出现的！<br>
所有的标准库容器的迭代器都定义了==  和!=，但是他们中的大多数都没有定义<运算符！！！<br>
迭代器类型<br>
**begin和end运算符**<br>
begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin 和 end返回const_iterator; 如果对象不是常量，返回iterator<br>
```cpp
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();
auto it2 = cv.begin(); 
```
如果对象只需读操作的话最好使用常量类型比如(const_iterator)为了便于得到const_iterator类型的返回值，C++11 新标准引入了两个新函数，分别是cbegin, cend<br>
auto it3 = v.cbegin();//不论vector对象或者string对象本身是否是常量，返回值都是const_iterator<br>
**结合解引用和成员访问操作**<br>
解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员<br>
(*it).empty() <=> it->empty()<br>
**迭代器运算**<br>
iter+n
iter-n
iter1 += n
iter1 -= n
iter1-iter2
<,>,>=,<=
举个关于使用迭代器运算的的一个经典算法，二分法搜索<br>
```cpp
auto beg = text.begin(),end = text.end();
auto mid = text.begin() +（end-beg)/2;
while(mid != end && *mid != soughor)
```
的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器。与vector不同的地方在于，数组的大小确定不变，不能随意向数组中增加元素。
**定义和初始化内置数组**<br>
```cpp
unsigned cnt = 42; //非常量表达式
constexpr unsigned sz = 42; //常量表达式
int arr[10]; //含有10个整数的数组
int *parr[sz]; // 含有42格整型指针的数组
string bad[cnt]; // wrong!!!cnt不是常量表达式
string strs[get_size()]; //当get_size()是constexpr时正确；否则错误
```
定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外vector一样，数组的元素应为对象，因此不存在引用的数组。<br>
显式初始化数组元素<br>
可以对数组的元素进行列表初始化，此时允许忽略数组的维度。<br>
如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来<br>
字符数组的特殊性<br>
字符数组有一种额外的初始化形式，我们可以用字符串字面值，对此类数组初始化。<br>
不允许拷贝和赋值<br>
不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。<br>
int a[] = [1,2,3];
int a2[] = a;// 不允许使用一个数组初始化另一个数组
a2 = a; //不能把一个数组直接赋值给另一个数组
*warning: 一些编译器支持数组的赋值，这就是所谓编译器扩展，但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作*<br>
**理解复杂的数组声明**<br>
和vector一样，数组能存放大多数类型的对象。<br>
```cpp
int *ptrs[10]; //ptrs是含有10个整型指针的数组；<br>
int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组<br>
int (&arrRef)[10] = arr ;//arrRef引用一个含有10个整数的数组<br>
int *(&array)[10] = ptrs; //array是数组的引用，该数组含有10个指针<br>
```
按照由内向外阅读的顺序，首先知道array是一个引用，然后观察右边知道，array引用的对象是一个大小为10 的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样array就是一个含有10个int型指针的数组的引用。<br>
要想理解数组声明的含义，最好的办法就是从数组的名字开始按照由内向外的顺序阅读<br>
**访问数组元素**<br>
*使用数组下标的时候，通常定义为size_t类型。size_t是一种机器相关的无符号类型，他被设计得足够大以便能表示内存中任意对象的大小。*<br>
**指针和数组**
*通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。*<br>
```cpp
string nums[] = {"one","two","three"};
string *p = &nums[0]; <=> string *p = nums;
```
**指针也是迭代器**<br>
vector和string的迭代器支持的运算，数组和指针全部支持<br>
标准库函数 begin and end<br>
int ia[] = {0,1,2,3,4,5};
int *beg = begin(ia);
int *last = end(ia);
**C风格字符串**<br>
**C边准库String函数**<br>
strlen(p) 返回p的长度，空字符串不计算在内<br>
strcmp(p1,p2) 比较p1 和p2的相等性，如果p1 == p2，返回0；如果p1 > p2，返回一个正值； 如果p1<p2，返回一个负值<br>
strcat(p1,p2) 将p2附加到p1之后，返回p1<br>
strcpy(p1,p2) 将p2拷贝给p1，返回p1<br>
**指针和多维数组**
当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针<br>
```cpp
int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2]; //
```
